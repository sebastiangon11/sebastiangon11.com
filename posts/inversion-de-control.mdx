---
title: Inversi√≥n de control
date: '18 de Noviembre de 2019'
description: Traducci√≥n a espa√±ol del blog de Kent C. Dodds
thumbnailUrl: '/posts/inversion-de-control.jpeg'
tags: ['Javascript', 'React']
language: 'ES'
---

> Esta es una traducci√≥n a espa√±ol del post <a href="https://kentcdodds.com/blog/inversion-of-control" target="_blank">Inversion of control</a> de Kent C. Dodds.

![√≥ptica invertida](/posts/inversion-de-control.jpeg)

<a
  href="https://egghead.io/lessons/egghead-implement-inversion-of-control?pl=kent-s-blog-posts-as-screencasts-eefa540c&af=5236ad"
  target="_blank"
>
  Mira "Implementando inversi√≥n de control‚Äù en egghead.io
</a>

Si alguna vez has escrito c√≥digo que fu√© usado en mas de un lugar, probablemente est√©s familiarizado con la siguiente historia:

1. Escribes un fragmento de c√≥digo reutilizable (funciones, componentes de React, un hook, etc.) y lo compartes (a tus compa√±eros de trabajo o lo publicas como c√≥digo abierto).
2. Alguien te contacta por un nuevo caso de uso que el c√≥digo que escribiste no soporta, pero podr√≠a hacerlo con una peque√±a modificaci√≥n.
3. Agregas un argumento/propiedad/opci√≥n a tu c√≥digo reutilizable y asocias la l√≥gica necesaria para poder soportar ese caso.
4. Repites los pasos 2 y 3 algunas veces (o varias üò¨)
5. El c√≥digo reutilizable, es ahora una pesadilla para utilizar y mantener üò≠

¬øQu√© es espec√≠ficamente lo que hace que el c√≥digo sea una pesadilla para usar y mantener?

Puede haber algunas cosas que causen este problema:

1. üòµ **Performance o tama√±o del bundle:** Ahora hay m√°s codigo para ejecutar por los dispositivos y eso puede impactar negativamente en la performance de varias formas. A veces puede ser tan malo que la gente decida ni siquiera investigar c√≥mo usar tu codigo debido a estos problemas.
2. üòñ **Sobrecarga de mantenimiento:** Antes, tu c√≥digo reutilizable solo ten√≠a algunas opciones y estaba enfocado en hacer una cosa cosa bien, pero ahora puede hacer muchas cosas diferentes y necesita documentaci√≥n para cada una. Adem√°s, tendr√°s un mont√≥n de gente pregunt√°ndote como usarlo para su caso de uso espec√≠fico que puede encajar bien o no con los casos de uso que ya soportas. Podr√≠as tener incluso dos funcionalidades que hagan lo mismo, pero con una peque√±a diferencia asi que terminar√°s respondiendo preguntas sobre cu√°l es la mejor para cada situaci√≥n.
3. üêõ **Complejidad en la implementaci√≥n:** Nunca es ‚Äúsolo un **if**‚Äù. Cada ramificaci√≥n de l√≥gica en tu c√≥digo se compone con las ramificaciones ya existentes. De hecho, hay situaciones donde pord√≠as estar soportando una combinaci√≥n de par√°metros que nadie est√© utilizando, pero debes asegurarte de que no se rompa cuando agregas nuevas funcionalidades porque en realidad nunca sabes si alguien la est√° usando o no.
4. üòï **Complejidad de la API:** Cada nuevo argumento/opci√≥n/propiedad que agregas a tu c√≥digo reutilizable hace mas dif√≠cil de usar para los usuarios finales porque ahora tienes una documentaci√≥n enorme que describe todas las funcionalidades disponibles y la gente tiene que aprender todas para poder usarlas de forma efectiva. Es menos agradable de usar porque a menudo la complejidad de tu API se traslada al c√≥digo de la aplicaci√≥n de los desarrolladores de forma que tambi√©n complejiza su c√≥digo.

Ahora todos est√°n tristes por esto. Hay que decir que el despliegue es de suma importancia cuando estamos desarrollando apps. Creo que ser√≠a genial si pudieramos generar abstracciones (lean <a href="https://kentcdodds.com/blog/aha-programming" target="_blank">AHA Programming</a>) y poder desplegar nuestras applicaciones. Si hubiera algo que podamos hacer para reducir los problemas con el c√≥digo reutilizable sin dejar de aprovechar los beneficios de esas abstracciones...

## Enter: Inversi√≥n de control

Uno de los principios que he aprendido y que es un mecanismo realmente efectivo para lograr simplicidad en las abstracciones es la "inversi√≥n de control". Aqu√≠ est√° lo que wikipedia dice sobre <a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank">inversi√≥n de control</a>.

> "... en la programaci√≥n tradicional, el c√≥digo personalizado que expresa el prop√≥sito del programa llama a bibliotecas reutilizables para que se encarguen de tareas gen√©ricas, pero con la inversi√≥n de control, es la biblioteca quien llama al c√≥digo personalizado o especifico para una tarea.‚Äù

Puedes pensar en esto como: "Has que tu abstracci√≥n haga menos cosas, y has que tus usuarios lo hagan en su lugar." Esto puede parecer contra intuitivo porque parte de lo que hace a la abstracci√≥n tan genial es que puede manejar toda la complajidad y las tareas repetitivas dentro de ella para que el resto del c√≥digo pueda mantenerse ‚Äúsimple", "ordenado" o "limpio". Pero como ya hemos experimentado, las abstraccionas tradicionales, usualmente no funcionan asi.

## ¬øQu√© es la inversi√≥n de control en el c√≥digo?

Primero, veamos un ejemplo:

<SyntaxHighlighter language="javascript">
  {`
// let's pretend that Array.prototype.filter does not exist
function filter(array) {
  let newArray = []
  for (let index = 0; index < array.length; index++) {
    const element = array[index]
    if (element !== null && element !== undefined) {
      newArray[newArray.length] = element
    }
  }
  return newArray\n
  // use case:\n
  filter([0, 1, undefined, 2, null, 3, 'four', ''])
  // [0, 1, 2, 3, 'four', '']
}
`}
</SyntaxHighlighter>

Ahora reproduzcamos el t√≠pico ‚Äúciclo de vida de una abstracci√≥n", agreguemos algunos casos de usos nuevos relacionados a esta abstracci√≥n y "mejoremosla" para que soporte esos nuevos casos.

<SyntaxHighlighter language="javascript">
  {`
// let's pretend that Array.prototype.filter does not exist
function filter(
  array,
  {
    filterNull = true,
    filterUndefined = true,
    filterZero = false,
    filterEmptyString = false,
  } = {},
) {
  let newArray = []
  for (let index = 0; index < array.length; index++) {
    const element = array[index]
    if (
      (filterNull && element === null) ||
      (filterUndefined && element === undefined) ||
      (filterZero && element === 0) ||
      (filterEmptyString && element === '')
    ) {
      continue
    }\n
    newArray[newArray.length] = element
}
return newArray
}\n
filter([0, 1, undefined, 2, null, 3, 'four', ''])
// [0, 1, 2, 3, 'four', '']\n
filter([0, 1, undefined, 2, null, 3, 'four', ''], {filterNull: false})
// [0, 1, 2, null, 3, 'four', '']\n
filter([0, 1, undefined, 2, null, 3, 'four', ''], {filterUndefined: false})
// [0, 1, 2, undefined, 3, 'four', '']\n
filter([0, 1, undefined, 2, null, 3, 'four', ''], {filterZero: true})
// [1, 2, 3, 'four', '']\n
filter([0, 1, undefined, 2, null, 3, 'four', ''], {filterEmptyString: true})
// [0, 1, 2, 3, 'four']
`}
</SyntaxHighlighter>

Ok, en realidad solo hay 6 casos de uso que nos importan, pero a√∫n asi debemos soportar una combinaci√≥n de 25 combinatorias (si no me equivoco).

Y esta es una abstracci√≥n relativamente simple, estoy seguro que se podr√≠a simplificar. A menudo cuando vuelves a ver una abstracci√≥n luego de un tiempo, te das cuenta de que podr√≠as simplificarla mucho m√°s para los casos de uso que en realidad deber√≠a soportar. Desafortunadamente, tan pronto como la abstracci√≥n soporta una nueva funcionalidad (como `{filterZero: true, filterUndefined: false}`), no querr√°s removerla por miedo a romper la aplicaci√≥n de algun desarrollador que la est√© usando.

Incluso acabaremos escribiendo tests para esos casos de uso que en realidad no necesitamos, solo por el hecho de que nuestra abstracci√≥n los soporta y "podr√≠amos‚Äù necesitarlos en el futuro. Entonces, cuando esos casos de uso no son m√°s necesarios, los seguiremos soportando porque nos olvidaremos, pensamos que los necesitaremos en un futuro, o simplemente porque tenemos muedo de tocar ese c√≥digo.

De acuerdo, ahora agreguemos algunas abstracciones en esta funci√≥n y apliquemos inversi√≥n de control para soportar todos estos casos de uso:

<SyntaxHighlighter language="javascript">
  {`
// let's pretend that Array.prototype.filter does not exist
function filter(array, filterFn) {
  let newArray = []
  for (let index = 0; index < array.length; index++) {
    const element = array[index]
    if (filterFn(element)) {
      newArray[newArray.length] = element
    }
  }
  return newArray
}\n
filter(
  [0, 1, undefined, 2, null, 3, 'four', ''],
  el => el !== null && el !== undefined,
)
// [0, 1, 2, 3, 'four', '']\n
filter([0, 1, undefined, 2, null, 3, 'four', ''], el => el !== undefined)
// [0, 1, 2, null, 3, 'four', '']\n
filter([0, 1, undefined, 2, null, 3, 'four', ''], el => el !== null)
// [0, 1, 2, undefined, 3, 'four', '']\n
filter(
  [0, 1, undefined, 2, null, 3, 'four', ''],
  el => el !== undefined && el !== null && el !== 0,
)
// [1, 2, 3, 'four', '']\n
filter(
  [0, 1, undefined, 2, null, 3, 'four', ''],
  el => el !== undefined && el !== null && el !== '',
)
// [0, 1, 2, 3, 'four']
`}
</SyntaxHighlighter>

Que bonito! Eso es mucho mas simple. Lo que hemos hecho es invertir el control! Delegamos la responsabilidad de decidir que elementos permanecen en el nuevo array de la funci√≥n `filter` a quien llama a la funci√≥n `filter`. Cabe destacar que la funci√≥n `filter` es a√∫n una abstracci√≥n √∫til, pero es mucho m√°s capaz.

Pero, ¬øLa abstracci√≥n anterior era tan mala? Tal vez no. Pero por el hecho de haber invertido el control, ahora podemos soportar mucho mas casos de usos particulares.

<SyntaxHighlighter language="javascript">
  {`
filter(
  [
    {name: 'dog', legs: 4, mammal: true},
    {name: 'dolphin', legs: 0, mammal: true},
    {name: 'eagle', legs: 2, mammal: false},
    {name: 'elephant', legs: 4, mammal: true},
    {name: 'robin', legs: 2, mammal: false},
    {name: 'cat', legs: 4, mammal: true},
    {name: 'salmon', legs: 0, mammal: false},
  ],
  animal => animal.legs === 0,
)
// [
//   {name: 'dolphin', legs: 0, mammal: true},
//   {name: 'salmon', legs: 0, mammal: false},
// ]
`}
</SyntaxHighlighter>

Imagina haber tenido que soportar todo esto antes de haber invertido el control. Hubiera sido una locura...

## ¬øUna API peor?

Una de las quejas mas comunes que escucho de la gente acerca de las APIs de inversi√≥n de control que he construido es: "Si, pero ahora es mas dif√≠cil de usar que antes‚Äú. Por ejemplo:

<SyntaxHighlighter language="javascript">
  {`
// before
filter([0, 1, undefined, 2, null, 3, 'four', ''])\n
// after
filter(
  [0, 1, undefined, 2, null, 3, 'four', ''],
  el => el !== null && el !== undefined,
)
`}
</SyntaxHighlighter>

Si, una de ellas es claramente m√°s facil de utilizar que la otra. Pero aqui est√° la cuesti√≥n de las APIs de inversi√≥n de control, puedes utilizarlas para re implementar la API anterior y generalmente es bastante trivial hacerlo. Por ejemplo:

<SyntaxHighlighter language="javascript">
  {`
function filterWithOptions(
  array,
  {
    filterNull = true,
    filterUndefined = true,
    filterZero = false,
    filterEmptyString = false,
  } = {},
) {
  return filter(
    array,
    element =>
      !(
        (filterNull && element === null) ||
        (filterUndefined && element === undefined) ||
        (filterZero && element === 0) ||
        (filterEmptyString && element === '')
      ),
  )
}
`}
</SyntaxHighlighter>

¬øGenial no? Asi que podemos construir abstracciones sobre la API de inversi√≥n de control logrando la API simple que la gente estaba buscando. Y a√∫n mejor, si nuestra "simple" API no es suficiente para su caso de uso, pueden usar los mismos bloques (building blocks) que utilizamos para construis la API de m√°s alto nivel para lograr el cometido de su tarea mas compleja. Ya no necesitan pedirnos que agreguemos una nueva funcionalidad como `filterWithOptions` y esperar a que la terminemos. Ahora tienen los bloques necesarios para construira ellos mismos porque les hemos dado las herramientas para hacerlo.

Ah, y solo por diversi√≥n:

<SyntaxHighlighter language="javascript">
  {`
function filterByLegCount(array, legCount) {
  return filter(array, animal => animal.legs === legCount)
}\n
filterByLegCount(
  [
    {name: 'dog', legs: 4, mammal: true},
    {name: 'dolphin', legs: 0, mammal: true},
    {name: 'eagle', legs: 2, mammal: false},
    {name: 'elephant', legs: 4, mammal: true},
    {name: 'robin', legs: 2, mammal: false},
    {name: 'cat', legs: 4, mammal: true},
    {name: 'salmon', legs: 0, mammal: false},
  ],
  0,
)
// [
//   {name: 'dolphin', legs: 0, mammal: true},
//   {name: 'salmon', legs: 0, mammal: false},
// ]
`}
</SyntaxHighlighter>

Puedes componer de la forma que te guste para resolver casos de uso comunes que tengas.

## Bueno pero, ¬øhablando en serio?

Eso funciona para casos de uso simples, pero ¬øqu√© tan bueno es este concepto en el mundo real?

Bueno, lo mas probable es que hayas usado alguna API de inversi√≥n de control sin darte cuenta. Por ejemplo, la funci√≥n `Array.prototype.filter` invierte el control. Como tambi√©n lo hace la funci√≥n `Array.prototype.map`.

Tambi√©n hay patrones con los que quizas est√©s familiarizado que son basicamente una forma de inversi√≥n de control.

Mis dos patrones favoritos para esto son <a href="https://kentcdodds.com/blog/compound-components-with-react-hooks" target="_blank">"Componentes compuestos‚Äù</a> y <a href="https://kentcdodds.com/blog/the-state-reducer-pattern" target="_blank">"Reductor de estado‚Äù</a>. Aqui hay un peque√±o ejemplo de como estos patrones pueden ser utilizados.

### Componentes compuestos

Supongamos que quieres construir un componente `Men√∫` que tiene un bot√≥n para abrir para abrirse y mostrar una lista de items cuando se clickea. Luego, cuando se selecciona un item, este ejecuta alguna acci√≥n. Un enfoque com√∫n para este tipo de compnentes es crear propiedades para cada una de estas caracter√≠sticas:

<SyntaxHighlighter language="javascript">
  {`
function App() {
  return (
    <Menu
      buttonContents={
        <>
          Actions <span aria-hidden>‚ñæ</span>
        </>
      }
      items={[
        {contents: 'Download', onSelect: () => alert('Download')},
        {contents: 'Create a Copy', onSelect: () => alert('Create a Copy')},
        {contents: 'Delete', onSelect: () => alert('Delete')},
      ]}
    />
  )
}
`}
</SyntaxHighlighter>

Esto permite personalizar muchas cosas de los items del Men√∫. Pero ¬øque pasa si quisieramos insertar una l√≠nea antes del bot√≥n `Delete`? ¬øDeber√≠amos agregar una opci√≥n m√°s a los items? Como por ejemplo: `precedeWithLine`? Hug. Tal vez tendr√≠amos un tipo especial de item del tipo `{contents: <hr />}`. Supongo que eso funcionar√≠a, pero entonces tambi√©n deber√≠amos considerar el caso en el que la propiedad `onSelect` no sea provista. Y sinceramente, esta ser√≠a una API rara.

Cuando est√°s pensando en como crear una buena API para gente que est√° intentando hacer las cosas de diferente formas, en lugar de terminar en `if`s y ternarios, considera la posibilidad de invertir el control. En este caso, ¬øqu√© pasar√≠a si le dieramos al usuario la responsabilidad de renderizar el men√∫? Usemos una de las fortalezas mas gandes de la composici√≥n de React:

<SyntaxHighlighter language="javascript">
  {`
function App() {
  return (
    <Menu>
      <MenuButton>
        Actions <span aria-hidden>‚ñæ</span>
      </MenuButton>
      <MenuList>
        <MenuItem onSelect={() => alert('Download')}>Download</MenuItem>
        <MenuItem onSelect={() => alert('Copy')}>Create a Copy</MenuItem>
        <MenuItem onSelect={() => alert('Delete')}>Delete</MenuItem>
      </MenuList>
    </Menu>
  )
}
`}
</SyntaxHighlighter>

La clave a notar aqu√≠ es que no hay un estado visible para el usuario de los componentes. El estado est√° implicitamente compartido entre estos componentes. Ese es el valor principal provisto por el patr√≥n de componentes compuestos. Utilizando esta caracter√≠stica, le hemos delegado el control del renderizado a los usuarios de nuestros componentes y ahora agregar una l√≠nea extra es bastante trivial e intuitivo. No hay ninguna documentaci√≥n que leer ni funcionalidades extra, ni c√≥dido ni tests. Gran ganancia para todos.

Puedes leer m√°s acerca de este patr√≥n en el <a href="https://kentcdodds.com/blog/compound-components-with-react-hooks" target="_blank">blog de Kent</a>. Gr√°cias a <a href="https://twitter.com/ryanflorence" target="_blank">Ryan Florence</a> que le ense√±o este patr√≥n a Kent.

### Reductor de estados (state reducer)

Este es un patr√≥n que cre√© Kent para resolver un problema de personalizaci√≥n de l√≥gica. Puedes leer m√°s acerca de este patron en mi blog <a href="https://kentcdodds.com/blog/the-state-reducer-pattern" target="_blank">"The state reducer pattern‚Äù</a> pero en esencia es que ten√≠a una biblioteca de inputs de b√∫squeda / autocompletado que se llamaba `Downshift` y alguien estaba construyendo una versi√≥n de selecci√≥n m√∫ltiple del componente, por lo que necesitaban que el men√∫ se mantenga abierto incluso luego de haber selecionado un elemento.

En `Downshift` ten√≠amos l√≥gica que indicaba que el men√∫ deb√≠a cerrarse cuando una se realizaba una selecci√≥n. La persona que necesitaba esta funcionalidad sugiri√≥ una prop `closeOnSelection`. Yo no estaba a favor de eso porque ya hab√≠a estado en ese camino apocaliptico y quer√≠a evitarlo.

Asi que en su lugar, propuse una API para que los devs puedan controlar como suceden los cambios de estado. Puedes pensar en el reductor de estados como una funci√≥n que es invocada cada vez que un componente est√° por cambiar de estado y le da al desarrollador la chance de modificar el cambio de estado que est√° suceder.

Aqu√≠ hay un ejemplo de como podr√≠as hacer para que downshift no cierre el men√∫ luego de haber seleccionado un item.

<SyntaxHighlighter language="javascript">
  {`
function stateReducer(state, changes) {
  switch (changes.type) {
    case Downshift.stateChangeTypes.keyDownEnter:
    case Downshift.stateChangeTypes.clickItem:
      return {
        ...changes,
        // we're fine with any changes Downshift wants to make
        // except we're going to leave isOpen and highlightedIndex as-is.
        isOpen: state.isOpen,
        highlightedIndex: state.highlightedIndex,
      }
    default:
      return changes
  }
}\n
// then when you render the component
// <Downshift stateReducer={stateReducer} {...restOfTheProps} />
`}
</SyntaxHighlighter>

Una vez que agregamos esta propiedad, obtuvimos muchisimos menos pedidos de personalizaci√≥n para este componente. Se volvi√≥ muchisimo mas capaz y mucho mas simple para que la gente pudiera hacer lo que quisiera.

### Render props

Solo quer√≠a hacer una r√°pida menci√≥n al patr√≥n <a href="https://reactjs.org/docs/render-props.html" target="_blank">render props</a> que es un ejemplo perfecto de inversi√≥n de control, pero no lo necesitamos tan seguido como antes, asi que no voy a hablar de √©l.

<a href="https://kentcdodds.com/blog/react-hooks-whats-going-to-happen-to-render-props" target="_blank">
  Lee el articlo de por qu√© no necesitamos m√°s render props
</a>

## Un mensaje de precauci√≥n

La inversi√≥n de control es una manera fant√°stica de evitar hacer asunciones incorrectas acerca de casos de uso futuros en nuestro c√≥digo reutilizable. Pero antes de que lo hagas, quisiera darte un consejo. Volvamos r√°pidamente a nuestro ejemplo:

<SyntaxHighlighter language="javascript">
  {`
// let's pretend that Array.prototype.filter does not exist
function filter(array) {
  let newArray = []
  for (let index = 0; index < array.length; index++) {
    const element = array[index]
    if (element !== null && element !== undefined) {
      newArray[newArray.length] = element
    }
  }
  return newArray
}\n
// use case:\n
filter([0, 1, undefined, 2, null, 3, 'four', ''])
// [0, 1, 2, 3, 'four', '']
`}
</SyntaxHighlighter>

¬øQu√© tal si eso es todo lo que necesitaramos que `filter` hiciera y nos encontramos con una situaci√≥n en la que necesitamos filtrar todo excepto los valores `null` y `undefined`? En este caso agregar inversi√≥n de control para un solo caso de uso solo har√≠a nuestro c√≥digo mas complejo y no agregar√≠a mucho valor.

Tal y como con las abstracciones, por favor seamos conscientes y apliquemos el principio de <a href="https://kentcdodds.com/blog/aha-programming" target="_blank">Programaci√≥n AHA</a> para evitar abstracciones prematuras.

## Conslusi√≥n

Espero haber sido √∫til. Les he mostrado algunos patrones en la comunidad de React que sacan provecho del concepto de inversi√≥n de control. Hay m√°s dando vueltas, y el concepto aplica para mucho m√°s que solo React (como vimos con el ejemplo de `filter`). La pr√≥xima vez que est√©s por agregar un `if` a la `funci√≥nPrincipal` de tu aplicaci√≥n, considera como podr√≠as inversir el control y mover la l√≥gica a donde esta est√© siendo usada (o si est√° siendo utilizada en muchos lugares, puedes construir una abstracci√≥n mas personalizada para esos caso de uso espec√≠ficos).

Si te gustar√≠a jugar con los ejemplos de este post, si√©ntete libre:

<a
  className="text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center mr-2 mb-2 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800"
  href="https://codesandbox.io/s/inversion-of-control-qunm8?fontsize=14&hidenavigation=1&theme=dark"
  target="_blank"
>
  Editar en CodeSandbox
</a>

P.D. Si te gusto este post, probablemente te guste esta charla:

<a
  href="https://www.youtube.com/watch?list=PLV5CVI1eNcJgNqzNwcs4UKrlJdhfDjshf&v=AiJ8tRRH0f8&feature=emb_imp_woyt"
  target="_blank"
>
  Kent C Dodds - Simply React
</a>
