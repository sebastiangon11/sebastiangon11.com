---
title: Soluciona los renderizados lentos antes de los re-renderizados
date: '9 de Septiembre de 2019'
description: Traducci√≥n del blog de Kent C. Dodds
thumbnailUrl: '/posts/fix-the-slow-render-before-you-fix-the-re-render.jpeg'
tags: ['functions', 'javascript', 'react']
language: 'ES'
---

> Esta es una traducci√≥n a espa√±ol del post [fix-the-slow-render-before-you-fix-the-re-render](https://kentcdodds.com/blog/fix-the-slow-render-before-you-fix-the-re-render) de Kent C. Dodds.

![alt text](/posts/fix-the-slow-render-before-you-fix-the-re-render.jpeg)

La performance es un problema grave y deber√≠amos construir nuestras aplicaci√≥nes lo mas r√°pidas posible. C√≥mo lo hagamos
tendr√° un gran impacto no solo en la efectividad de nuestras optimizaciones sino tambi√©n en la complejidad de nuestro c√≥digo
(la velocidad con la que podemos realizar mejoras y cambios en el futuro).

Cu√°ndo hablamos se optimizaciones en React, una de las cosas que las personas mencionan muy seguido son los "re-renders" - los re renderizados -. Aseguremonos de que estamos hablando de lo mismo:

<SyntaxHighlighter showLineNumbers language="javascript">
  {`function Counter() {
  const [count, setCount] = React.useState(0)
  const increment = () => setCount(c => c + 1)
  return <button onClick={increment}>{count}</button>
}`}
</SyntaxHighlighter>

<ButtonCounter />

Cada vez que clickeamos en ese bot√≥n, estamos disparando un re-render. Pero, ¬øQu√© es un re-render?

## ¬øQu√© es un re-render?

Cuando react fu√© lanzado por primera vez, muchas gente se centr√≥ en las mejoras de performance sobre las bibliotecas de UIs existentes gracias al "DOM Virtual" de React. Las bibliotecas de UI m√°s populares hasta ese entonces dejaban a tu criterio cu√°ndo actualizar el DOM o lo hac√≠a estas mismas por t√≠, pero lo hac√≠an secuencialmente por aca "componente" (o directiva) que necesitaba actualizarse. Basicamente se reduce a esto:

1. Dado que actualizar el DOM es lento (como cuando se llama a <code>element.appendChild(childElement)</code>)
2. Y ese problema de performance se agrava cuantas m√°s veces lo haces.
3. Y se pueden evitar algunos problemas de performance haciendo todas las actualizaciones necesarias a la vez
4. Si se agrupan todas estas actualizaciones, se pueden reducir los problemas de performance en las actualizaciones del DOM que ocurren sucesivamente en un corto per√≠odo de tiempo.

As√≠ que el equipo de React decidi√≥ agrupar las actualizaciones del DOM, para que si hubiera un cambio de estado que resultara en treinta actualizaciones de DOM, todas sucedan de una sola vez, en lugar de ejecutarse una tras otra. Sin embargo, para lograr este agrupamiento (batching), tenian que hacerse cargo de las actualizaciones del DOM, por eso tenemos <code>React.createElement</code> (qu√© es lo que es JSX) para describir como queremos que se vea el DOM, y cuando hay un cambio de estado, React llama a nuestra funci√≥n nuevamente para obtener los elementos de React (React elements) que necestiamos renderizados en el DOM. Entonces compara esos nuevos elementos con los que le dimos la √∫ltima vez que renderizamos. A partir de eso, puede decidir qu√© actualizaciones hacer y luego trasladar esas actualizaciones al DOM de la manera m√°s eficaz posible. Este proceso de actualizaci√≥n del DOM se llama "commiting" (confirmaci√≥n) , porque est√° tomando los elementos de React que renderizamos y los "aplica" o "confirma" en el DOM.

Esta es una distinci√≥n realmente importante y no quiero que se pase por alto (y los nombres son un poco enga√±osos, as√≠ que quiero dejarlo claro). Un "render" ocurre cuando React llama a una funci√≥n para obtener elementos de React (React elements). La "Reconciliaci√≥n" (Reconciliation) ocurre cuando React compara esos elementos de React con los elementos previamente renderizados. Una "confirmaci√≥n" (commit) es cuando React toma esas diferencias y realiza las actualizaciones en el DOM.

<SyntaxHighlighter language="javascript">
  {`
  renderizado (render) ‚Üí reconciliaci√≥n (reconciliation) ‚Üí confirmaci√≥n (commit)
                     ‚Üñ                                    ‚Üô
                        state change (cambio de estado)
  `}
</SyntaxHighlighter>

Para clarificar:

- La fase de "render": Crea los elementos de React React.createElement (<a href="https://kentcdodds.com/blog/what-is-jsx" target="_blank">conocer m√°s</a>)

- La fase de "reconciliaci√≥n": compara los elementos previamente renderizados contra los nuevos elementos (<a href="https://es.reactjs.org/docs/reconciliation.html" target="_blank">conocer m√°s</a>)
- La fase de "confirmaci√≥n": Actualiza el DOM (si es necesario)

Tipicamente, la fase m√°s lenta es la fase de confirmaci√≥n, cuando se actualiza el DOM. Pero no todas las actualizaciones son lentas. De hecho, es probablemente un poco enga√±oso afirmar que "el DOM es lento" porque tiene mas matices que eso. Las actualizaciones del DOM como agregar o remover manejadores de eventos (event listeners) son muy r√°pidas. La parte lenta del DOM es el "layout" <a href="https://www.youtube.com/watch?v=3bc71-xzoWA" target="_blank">aprende m√°s sobre el layout</a>.

Gracias al agrupamiento y al c√≥digo optimizado de React, podremos evitar muchas de las desventajas de tener que preocuparnos por este problema, pero definitivamente puede afectarnos en alguna ocaci√≥n.

## Re-renderizados innecesarios

Solo por el hecho de que un componente se re-renderice no significa que vaya a resultar en una actualizaci√≥n del DOM. Aqu√≠ hay un ejemplo r√°pido de eso:

<SyntaxHighlighter showLineNumbers language="javascript">
  {`function Foo() {
  return <div>FOO!</div>
}`}
</SyntaxHighlighter>

<SyntaxHighlighter showLineNumbers language="javascript">
  {`function Counter() {
  const [count, setCount] = React.useState(0)
  const increment = () => setCount(c => c + 1)
  return (
    <>
      <Foo />
      <button onClick={increment}>{count}</button>
    </>
  )
}`}
</SyntaxHighlighter>

Cada vez que clickeas en el bot√≥n, la funci√≥n Foo se ejecuta, pero el DOM que representa no se re-renderiza. A causa de esto, no hay ninguna actualizaci√≥n en el DOM para este componente. Esto se conoce comunmente como "re-render innecesario".

Desafortunadamente, ha habido mucha confusi√≥n en cuanto a la diferencia entre "renderizados" y "commits". Mucha gente conoce (o al menos ha o√≠do) que "el DOM es lento", pero pocos se dan cuenta de que solo porque un componente se re-renderice, no significa que el DOM ser√° actualizado. Dado a este desentendimiento, creen que es un cuello de botella en la performance que un componente se renderice cuando no necesita actualizar su DOM subyacente.

Esto puede ser un problema en algunos casos, pero engeneral incluso en navegadores m√≥viles y dispositivos low-end son muy r√°pidos para crear objetos (fase de render) y compararlos (fase de reconciliaci√≥n). Entonces, cu√°l es el problema con los re-renderizados?

## Renderizados lentos

Si javasacript es tan r√°pido para administrar las fases de renderizado y reconciliaci√≥n, entonces ¬øPor qu√© mi aplicaci√≥n se congela cuando tengo re-renderizados innecesarios? En esa situaci√≥n, sugerir√≠a que tu problema o se encuentra en los re-renderizados innecesarios, sino que m√°s probablemente sea con un renderizado lento en general. Hay algo que tu c√≥digo est√° haciendo durante la fase de renderizado que est√° haciendo las cosas lentas. Deber√≠as diagnosticar y arreglar ese prolema primero. Una vez que hayas solucionado ese problema, entonces puedes analizar (profiler) tu aplicaci√≥n nuevamente y ver sii sigues teniendo problemas con re-renderizados innecesarios.

De hecho, si dejas un renderizado lento y solo reduces la cantidad de re-renderizados, terminar√≠as en una situaci√≥n peor, y probablemente con c√≥digo mucho mas complejo.

Quizas esto me lleve a al punto. Supongamos que debes golpearte cada vez que parpadeas üòâü§õ ü•¥. Lo que probablemente pienses ser√°: "Oh, deber√≠a dejar de parpadear tanto!" Sabes que dir√≠a yo? Dir√≠a que deber√≠as dejar de golpearte en la cara cada vez que parpadeas! En lugar de reducir la frecuencia con la que suceden las cosas malas (renderizados lentos), tal vez deber√≠amos eliminar la situaci√≥n indeseada y sentirte libre de parpadear (renderizar) tanto como tus ojos lo necesiten üòâ.

![Deja de golpearte](https://res.cloudinary.com/kentcdodds-com/image/upload/f_auto,q_auto,dpr_2.0/v1625032718/kentcdodds.com/content/blog/fix-the-slow-render-before-you-fix-the-re-render/stop-hitting-yourself.gif)

## Como solucionar los renderizados lentos

Entonces hemos concluido que primero necesitamos arreglar los renderizados lentos. Entonces podremos determinar si los re-renderizados son a√∫n un problema. ¬øC√≥mo solucionamos un renderizado lento?. A menudo ya conoces cu√°l interacci√≥n est√° causando una mala experiencia para el usuario. En otras cosaciones se produce cuando abres una pesta√±a, clickeas un bot√≥n o escribes en un campo de texto.

Esto es lo que deber√≠as hacer: Usando la herramienta de an√°lisis (profiling) tu navegador, inicia una sesi√≥n y det√©n el proceso de nuevo. Por ejemplo: <a href="https://twitter.com/brian_d_vaughn/status/1171158009277403136" target="_blank">Enlace a twitter</a>

Una vez que encuentras cu√°l es tu parte (o de tus dependencias) que est√° tomando m√°s tiempo, arregla esos problemas, intenta nuevamente con el an√°lisis y observa las mejoras (o deterioros). No olvides las herramientas de an√°lisis de React, son realmente muy buenas! <a href="https://twitter.com/brian_d_vaughn/status/1126950967201546240" target="_blank">Enlace a twitter</a>

## Conclusi√≥n

No importa si el 100% de tus renderizados son necesatios, si son lentos, produciran una mala experiencia para los usuarios. Deja de golpearte la cara cada vez que parpadeas. Soluciona los renderizados lentos primero. Luego ocupate de los re-renderizados (si a√∫n es necesario). Buena suerte!
