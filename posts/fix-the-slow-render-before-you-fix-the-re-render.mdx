---
title: Fix the slow render before you fix the re-render
date: 'September 9, 2019'
description: Translation from Kent Dodds blog
thumbnailUrl: '/posts/fix-the-slow-render-before-you-fix-the-re-render.jpeg'
tags: ['functions', 'javascript', 'react']
languaje: 'ES'
---

![alt text](/posts/fix-the-slow-render-before-you-fix-the-re-render.jpeg)

La performance es un problema grave y deberíamos construir nuestras aplicaciónes lo mas rápidas posible. Cómo lo hagamos
tendrá un gran impacto no solo en la efectividad de nuestras optimizaciones sino también en la complejidad de nuestro código
(la velocidad con la que podemos realizar mejoras y cambios en el futuro).

Cuándo hablamos se optimizaciones en React, una de las cosas que las personas mencionan muy seguido son los "re-renders" - los re renderizados -. Aseguremonos de que estamos hablando de lo mismo:

<SyntaxHighlighter showLineNumbers language="javascript">
  {`function Counter() {
  const [count, setCount] = React.useState(0)
  const increment = () => setCount(c => c + 1)
  return <button onClick={increment}>{count}</button>
}`}
</SyntaxHighlighter>

<ButtonCounter />

Cada vez que clickeamos en ese botón, estamos disparando un re-render. Pero, ¿Qué es un re-render?

## ¿Qué es un re-render?

When React was first released, a lot of people focused on the performance improvements over existing UI libraries thanks to React's "Virtual DOM". Most popular existing UI libraries at the time would either leave you to update the DOM yourself, or would update the DOM for you, but do so sequentially for every "component" (or directive) that needed updating. Basically it comes down to this:

1. Given that it's slow to update the DOM (like when calling <code>element.appendChild(childElement)</code> for example).
2. And that performance issue is compounded the more times you do it.
3. And can side-step some perf issues by doing all necessary updates at once
4. If we batch all DOM updates, then we can reduce the performance issues of updating the DOM multiple times in rapid succession.

So the React team decided to batch DOM updates, so if there was a state change that resulted in thirty DOM updates, they would all happen at once, rather than running them one after another. To do this batching though, they would have to take ownership over updating the DOM, so we have React.createElement (which is what JSX is) to describe what we want the DOM to look like, and when there's a state change, React calls our function again to get the React elements we need rendered to the DOM. It then compares those new React elements with the ones we gave it last time we rendered. From that it can tell what DOM updates to make, and then makes those updates for us in the most performant way possible. The process of updating the DOM is called "committing" because we're taking the React elements that you "rendered" and "commit" those updates to the DOM.

This is a really important distinction and I don't want you to miss it (and the names are a tiny bit misleading, so I want to make it clear). A "render" is when React calls your function to get React elements. "Reconciliation" is when React compares those React elements with the previously rendered elements. A "commit" is when React takes those differences and makes the DOM updates.

<SyntaxHighlighter language="javascript">
  {`
  render → reconciliation → commit
      ↖                   ↙
          state change
  `}
</SyntaxHighlighter>
